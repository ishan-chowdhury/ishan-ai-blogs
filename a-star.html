<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>A* Search Algorithm</title>

  <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;500;600&display=swap" rel="stylesheet">

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>

  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: "base",
      themeVariables: {
        primaryColor: "#1e1e1e",
        primaryTextColor: "#ddd",
        lineColor: "#ddd",
        secondaryColor: "#2d2d2d",
        fontFamily: "Fira Code"
      }
    });
  </script>

  <style>
    body {
      font-family: "Fira Code", monospace;
      background: #1e1e1e;
      color: #ddd;
      max-width: 1100px;
      margin: auto;
      padding: 2rem;
      line-height: 1.8;
    }

    h1, h2, h3 {
      color: #ffffff;
    }

    pre {
      background: #2d2d2d;
      padding: 1rem;
      border-radius: 8px;
      overflow-x: auto;
      width: 100%;
    }

    code {
      color: #ddd;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin: 1rem 0;
    }

    th, td {
      border: 1px solid #444;
      padding: 8px;
    }

    a {
      color: #7aa2f7;
      text-decoration: none;
    }

    hr {
      border: 1px solid #333;
      margin: 2rem 0;
    }

    .mermaid {
      display: flex;
      justify-content: center;
    }
  </style>
</head>

<body>

<a href="index.html">← Back to Home</a>

<h1>A* Search Algorithm: Intelligent Pathfinding in AI</h1>

<p>
Search algorithms are at the heart of many Artificial Intelligence systems. Whenever an AI system needs
to decide <i>where to go next</i>, <i>what action to take</i>, or <i>how to reach a goal efficiently</i>,
a search algorithm is usually involved.
</p>

<p>
From simple maze solvers to advanced navigation systems in self-driving cars, search techniques make
intelligent decision-making possible. Among all these techniques, the <b>A*</b> (A-star) algorithm
stands out because it is both <b>efficient</b> and <b>optimal</b>.
</p>

<p>
Unlike basic search methods that explore blindly, A* uses intelligent guidance to focus only on the
most promising paths. This makes it especially useful in real-world applications where speed and
accuracy both matter.
</p>

<p>This blog will walk you through:</p>
<ul>
  <li>How A* works at a conceptual level</li>
  <li>How it compares with other search algorithms</li>
  <li>How to implement it in Python</li>
  <li>Why heuristics are so important</li>
  <li>How A* behaves in practice using an example</li>
</ul>

<hr>

<h2>1. Introduction to A* Search</h2>

<p>
A* is classified as a <b>best-first search algorithm</b>. This means that it always chooses the next
node based on what looks like the best option at the moment.
</p>

<p>
However, what makes A* special is the way it defines “best”. Instead of relying only on how far a node
is from the goal or how much cost has already been spent, A* combines both ideas.
</p>

<p>
For each node, A* computes:
</p>

<p>$$ f(n) = g(n) + h(n) $$</p>

<ul>
  <li><b>g(n)</b>: The actual cost from the start node to the current node</li>
  <li><b>h(n)</b>: A heuristic estimate of the cost from the current node to the goal</li>
  <li><b>f(n)</b>: The estimated total cost of the solution through this node</li>
</ul>

<p>
By doing this, A* avoids wasting time on paths that are clearly inefficient. It focuses on routes that
are both <i>cheap so far</i> and <i>promising for the future</i>.
</p>

<p>
This balance between exploration and guidance is what makes A* one of the most practical and widely
used algorithms in Artificial Intelligence.
</p>

<hr>

<h2>A* Search Flowchart</h2>

<p>
The following flowchart summarizes the main steps followed by the A* algorithm during execution:
</p>

<div class="mermaid">
flowchart TD
    A[Start] --> B[Initialize Open Set]
    B --> C[Set g start to zero]
    C --> D{Open Set Empty}
    D -->|Yes| Z[Failure]
    D -->|No| E[Select Node with Lowest f]
    E --> F{Is Goal Reached}
    F -->|Yes| G[Reconstruct Path]
    G --> H[End]
    F -->|No| I[Expand Neighbors]
    I --> J[Compute g h and f]
    J --> K[Update Open Set]
    K --> D
</div>

<p>
At every step, A* selects the node with the smallest estimated total cost and expands it. If the goal
is reached, the algorithm reconstructs the path and stops.
</p>

<hr>

<h2>2. How A* is Different from Other Search Algorithms</h2>

<p>
Different search algorithms prioritize different types of information. Some focus only on distance,
while others focus only on cost. A* combines both.
</p>

<table>
<tr><th>Algorithm</th><th>Uses g(n)</th><th>Uses h(n)</th><th>Optimal</th><th>Fast</th></tr>
<tr><td>BFS</td><td>No</td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td>Dijkstra</td><td>Yes</td><td>No</td><td>Yes</td><td>No</td></tr>
<tr><td>Greedy</td><td>No</td><td>Yes</td><td>No</td><td>Yes</td></tr>
<tr><td><b>A*</b></td><td>Yes</td><td>Yes</td><td>Yes</td><td>Yes</td></tr>
</table>

<p>
Breadth-First Search guarantees the shortest path only when all edges have equal cost.  
Dijkstra’s algorithm guarantees optimality but explores many unnecessary nodes.  
Greedy search is fast but often chooses poor paths.
</p>

<p>
A* carefully balances speed and accuracy, making it ideal for most AI applications.
</p>

<hr>

<h2>3. How to Implement A* in Python</h2>

<p>
Below is a simple grid-based implementation of the A* algorithm using Python. This version uses the
Manhattan distance as a heuristic.
</p>

<pre><code>
import heapq

def heuristic(a, b):
    return abs(a[0] - b[0]) + abs(a[1] - b[1])

def a_star(grid, start, goal):
    rows, cols = len(grid), len(grid[0])
    
    open_set = []
    heapq.heappush(open_set, (0, start))
    
    came_from = {}
    g_score = {start: 0}
    
    while open_set:
        _, current = heapq.heappop(open_set)
        
        if current == goal:
            path = []
            while current in came_from:
                path.append(current)
                current = came_from[current]
            path.append(start)
            return path[::-1]
        
        x, y = current
        neighbors = [(x+1,y), (x-1,y), (x,y+1), (x,y-1)]
        
        for nx, ny in neighbors:
            if 0 <= nx < rows and 0 <= ny < cols and grid[nx][ny] == 0:
                neighbor = (nx, ny)
                tentative_g = g_score[current] + 1
                
                if neighbor not in g_score or tentative_g < g_score[neighbor]:
                    g_score[neighbor] = tentative_g
                    f = tentative_g + heuristic(neighbor, goal)
                    heapq.heappush(open_set, (f, neighbor))
                    came_from[neighbor] = current
    
    return None
</code></pre>

<p>
This implementation maintains an open set of nodes to explore and always selects the node with the
lowest estimated cost.
</p>

<hr>

<h2>4. Properties of A*</h2>

<h3>Optimal</h3>
<p>
When an admissible heuristic is used, A* is guaranteed to find the shortest possible path.
</p>

<h3>Complete</h3>
<p>
If a solution exists, A* will always find it, provided all step costs are positive.
</p>

<p><b>Time Complexity:</b> $$ O(b^d) $$</p>
<p><b>Space Complexity:</b> $$ O(b^d) $$</p>

<p>
While A* is powerful, it can also be memory-intensive. This is why heuristic design is so important in
large search spaces.
</p>

<hr>

<h2>5. Heuristics and Optimality</h2>

<p>
A heuristic is a function that estimates how far a node is from the goal.
</p>

<p>$$ h(n) \approx \text{distance to goal} $$</p>

<p>
Good heuristics help A* reduce unnecessary exploration, while bad heuristics can slow it down.
</p>

<p><b>Admissible heuristic:</b></p>
<p>$$ h(n) \leq h^*(n) $$</p>

<p><b>Consistent heuristic:</b></p>
<p>$$ h(n) \leq c(n,n') + h(n') $$</p>

<table>
<tr><th>Heuristic</th><th>Use Case</th></tr>
<tr><td>Manhattan</td><td>Grid movement</td></tr>
<tr><td>Euclidean</td><td>Continuous space</td></tr>
<tr><td>Diagonal</td><td>8-direction grids</td></tr>
<tr><td>Zero</td><td>Dijkstra</td></tr>
</table>

<hr>

<h2>6. Example Problem Using A*</h2>

<p>
Let’s apply A* to a small graph-based problem to see how it works in practice.
</p>

<div class="mermaid">
graph LR
S -->|1| A
A -->|3| G
S -->|4| B
B -->|2| G
A -->|1| B
</div>

<table>
<tr><th>Node</th><th>h(n)</th></tr>
<tr><td>S</td><td>5</td></tr>
<tr><td>A</td><td>3</td></tr>
<tr><td>B</td><td>2</td></tr>
<tr><td>G</td><td>0</td></tr>
</table>

<p>
A* evaluates both paths and chooses the one with the lower estimated total cost.
</p>

<p><b>Final Path:</b> S → A → G (Cost = 4)</p>

<hr>

<h2>7. Conclusion</h2>

<p>
A* remains one of the most practical and widely used search algorithms in Artificial Intelligence.
</p>

<p>
By combining real path costs with intelligent heuristics, it finds optimal solutions efficiently.
Whether you are working on games, robotics, or AI planning systems, understanding A* is a valuable
skill.
</p>

<p>
Mastering A* also builds a strong foundation for more advanced AI techniques such as heuristic search,
planning algorithms, and reinforcement learning.
</p>

</body>
</html>
